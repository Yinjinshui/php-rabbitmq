# php-rabbitmq

**1.normal** 

    普通队列
    
**2.queue-ttl**

    给队列设置过期时间，过期队列进入死信队列
    说明:触发队列的过期时间，队列中的所有信息都会进入死信队列
    
**3.message-ttl**

    给队列的消息设置过期时间
    说明：如果单独设置消息的 TTL，则可能会造成队列中的消息阻塞，即前一条消息没有出队（没有被消费），后面的消息无法投递
    
    主要过程：
    
    生产者 —> 原交换机 —> 原队列(超过 TTL 之后) —> 死信交换机 —> 死信队列 —> 最终消费者
    
    使用死信队列实现延时消息的缺点：
    
    （1）如果统一用队列来设置消息的 TTL，当梯度非常多的情况下，比如 1 分钟，2 分钟，5 分钟，10 分钟，20 分钟，30 分钟......需要创建很多交换机和队列来路由消息。
    
    （2）如果单独设置消息的 TTL，则可能会造成队列中的消息阻塞，即前一条消息没有出队（没有被消费），后面的消息无法投递。比如第一条消息过期 TTL 是 30min，第二条消息 TTL 是 10min。10 分钟后，即使第二条消息应该投递了，但是由于第一条消息 还未出队，所以无法投递。
    
    （3）可能存在一定时间误差

    
**4.message-two-ttl**

    给队列的消息设置过期时间,消息过期进入死信队列
    说明：如果单独设置消息的 TTL，则可能会造成队列中的消息阻塞，即前一条消息没有出队（没有被消费），后面的消息无法投递
            
        
    主要过程：
    
    生产者 —> 原交换机 —> 原队列(超过 TTL 之后) —> 死信交换机 —> 死信队列 —> 最终消费者
    
    使用死信队列实现延时消息的缺点：
    
    （1）如果统一用队列来设置消息的 TTL，当梯度非常多的情况下，比如 1 分钟，2 分钟，5 分钟，10 分钟，20 分钟，30 分钟......需要创建很多交换机和队列来路由消息。
    
    （2）如果单独设置消息的 TTL，则可能会造成队列中的消息阻塞，即前一条消息没有出队（没有被消费），后面的消息无法投递。比如第一条消息过期 TTL 是 30min，第二条消息 TTL 是 10min。10 分钟后，即使第二条消息应该投递了，但是由于第一条消息 还未出队，所以无法投递。
    
    （3）可能存在一定时间误差

    
**5. 延迟插件rabbitmq_delayed_message_exchange**
    
    延迟交换机：x-delayed-message
    
    说明；第一条消息过期 TTL 是 30min，第二条消息 TTL 是 10min，延迟交换机不会堵塞，触发过期时间的数据会被交换机优先投递到队列中
    
    
    安装延迟交换机安装：https://blog.csdn.net/qq_36025814/article/details/106647467
    延迟交换机插件地址：https://www.rabbitmq.com/community-plugins.html
    