# php-rabbitmq

**1.normal** 

    普通队列
    
**2.queue-ttl**

    给队列设置过期时间，过期队列进入死信队列
    
**3.message-ttl**

    给队列的消息设置过期时间
    
    主要过程：
    
    生产者 —> 原交换机 —> 原队列(超过 TTL 之后) —> 死信交换机 —> 死信队列 —> 最终消费者
    
    使用死信队列实现延时消息的缺点：
    
    （1）如果统一用队列来设置消息的 TTL，当梯度非常多的情况下，比如 1 分钟，2 分钟，5 分钟，10 分钟，20 分钟，30 分钟......需要创建很多交换机和队列来路由消息。
    
    （2）如果单独设置消息的 TTL，则可能会造成队列中的消息阻塞，即前一条消息没有出队（没有被消费），后面的消息无法投递。比如第一条消息过期 TTL 是 30min，第二条消息 TTL 是 10min。10 分钟后，即使第二条消息应该投递了，但是由于第一条消息 还未出队，所以无法投递。
    
    （3）可能存在一定时间误差
    ————————————————
    版权声明：本文为CSDN博主「KeepMoving++」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
    原文链接：https://blog.csdn.net/u011212394/article/details/100086728
    
**4.message-two-ttl**

    给队列的消息设置过期时间,消息过期进入死信队列
        
    主要过程：
    
    生产者 —> 原交换机 —> 原队列(超过 TTL 之后) —> 死信交换机 —> 死信队列 —> 最终消费者
    
    使用死信队列实现延时消息的缺点：
    
    （1）如果统一用队列来设置消息的 TTL，当梯度非常多的情况下，比如 1 分钟，2 分钟，5 分钟，10 分钟，20 分钟，30 分钟......需要创建很多交换机和队列来路由消息。
    
    （2）如果单独设置消息的 TTL，则可能会造成队列中的消息阻塞，即前一条消息没有出队（没有被消费），后面的消息无法投递。比如第一条消息过期 TTL 是 30min，第二条消息 TTL 是 10min。10 分钟后，即使第二条消息应该投递了，但是由于第一条消息 还未出队，所以无法投递。
    
    （3）可能存在一定时间误差
    ————————————————
    版权声明：本文为CSDN博主「KeepMoving++」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
    原文链接：https://blog.csdn.net/u011212394/article/details/100086728
    
    